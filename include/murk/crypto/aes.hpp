#pragma once

#include "murk/data.hpp"
#include "murk/flows/bytes.hpp"

namespace murk::crypto::aes {
  constexpr uint8_t sbox[256] = {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
                                ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
                                ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
                                ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
                                ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
                                ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
                                ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
                                ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
                                ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
                                ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
                                ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
                                ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
                                ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
                                ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
                                ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
                                ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

  constexpr uint8_t inv_sbox[256] = {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d};

  constexpr size_t state_size = 16;

  using table_t = std::array<uint8_t, state_size>;
  using table_ref_t = nonstd::span<uint8_t, state_size>;
  using round_constant_t = std::array<uint8_t, 4>;

  inline void sub_bytes(table_ref_t tab) {
    for (auto& i : tab)
      i = sbox[i];
  }
  inline void unsub_bytes(table_ref_t tab) {
    for (auto& i : tab)
      i = inv_sbox[i];
  }

  inline void shift_rows(table_ref_t tab) {
    table_t ref;
    std::copy(tab.begin(), tab.end(), ref.begin());
    tab[ 1] = ref[ 5]; tab[ 5] = ref[ 9]; tab[ 9] = ref[13]; tab[13] = ref[ 1];
    tab[ 2] = ref[10]; tab[ 6] = ref[14]; tab[10] = ref[ 2]; tab[14] = ref[ 6];
    tab[ 3] = ref[15]; tab[ 7] = ref[ 3]; tab[11] = ref[ 7]; tab[15] = ref[11];
  }

  inline void unshift_rows(table_ref_t tab) {
    table_t ref;
    std::copy(tab.begin(), tab.end(), ref.begin());
    tab[ 5] = ref[ 1]; tab[ 9] = ref[ 5]; tab[13] = ref[ 9]; tab[ 1] = ref[13];
    tab[10] = ref[ 2]; tab[14] = ref[ 6]; tab[ 2] = ref[10]; tab[ 6] = ref[14];
    tab[15] = ref[ 3]; tab[ 3] = ref[ 7]; tab[ 7] = ref[11]; tab[11] = ref[15];
  }

  inline void mix_columns(table_ref_t tab) {
    // Thx wikipedia
    auto* r = tab.data();

    unsigned char a[4];
    unsigned char b[4];
    unsigned char c;
    unsigned char h;

    /* The array 'a' is simply a copy of the input array 'r'
     * The array 'b' is each element of the array 'a' multiplied by 2
     * in Rijndael's Galois field
     * a[n] ^ b[n] is element n multiplied by 3 in Rijndael's Galois field */

    for (c = 0; c < 4; c++) {
        a[c] = r[c];
        /* h is 0xff if the high bit of r[c] is set, 0 otherwise */
        h = (unsigned char)((signed char)r[c] >> 7); /* arithmetic right shift, thus shifting in either zeros or ones */
        b[c] = r[c] << 1; /* implicitly removes high bit because b[c] is an 8-bit char, so we xor by 0x1b and not 0x11b in the next line */
        b[c] ^= 0x1B & h; /* Rijndael's Galois field */
    }

    r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 */
    r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 */
    r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 */
    r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 */
  }

  inline void add_round_key(table_ref_t tab, table_ref_t key) {
    murk::xor_bytes_inplace(tab, key);
  }

  /// If you end up using this namespace, something has gone _very_ wrong
  namespace rcon_detail {
    /// @param i the 0-indexed round number, but NOT 0!!!
    constexpr inline void update_round_constant(round_constant_t& prev, uint8_t i) {
      [[unlikely]]
      if (i == 1)
        prev = {1, 0, 0, 0};
      else {
        uint16_t f = prev.front();
        f = (f << 1) ^ (0x11b & -(f >> 7));
        prev[0] = f;
      }
    }

    constexpr round_constant_t round_constants[10] = {
      {0x01, 0x00, 0x00, 0x00},
      {0x02, 0x00, 0x00, 0x00},
      {0x04, 0x00, 0x00, 0x00},
      {0x08, 0x00, 0x00, 0x00},
      {0x10, 0x00, 0x00, 0x00},
      {0x20, 0x00, 0x00, 0x00},
      {0x40, 0x00, 0x00, 0x00},
      {0x80, 0x00, 0x00, 0x00},
      {0x1B, 0x00, 0x00, 0x00},
      {0x36, 0x00, 0x00, 0x00}
    };

    inline void rot_word(round_constant_t& rcon) {
      uint8_t b;
      b = rcon[0];
      rcon[0] = rcon[1];
      rcon[1] = rcon[2];
      rcon[2] = rcon[3];
      rcon[3] = b;
    }

    inline void sub_word(round_constant_t& rcon) {
      rcon[0] = sbox[rcon[0]];
      rcon[1] = sbox[rcon[1]];
      rcon[2] = sbox[rcon[2]];
      rcon[3] = sbox[rcon[3]];
    }

    inline void schedule_core(round_constant_t& rcon, uint8_t i) {
      rot_word(rcon);
      sub_word(rcon);
      update_round_constant(rcon, i);
    }
  }

  template<int KeyBits>
  constexpr int get_round_count();
  template<>
  constexpr int get_round_count<128>() { return 11; }
  template<>
  constexpr int get_round_count<176>() { return 13; }
  template<>
  constexpr int get_round_count<256>() { return 15; }

  template<int KeyBits>
  using round_keys_t = std::array<table_t, get_round_count<KeyBits>()>;

  template<int KeyBits>
  inline void expand_key(round_keys_t<KeyBits>& out, nonstd::span<const uint8_t, KeyBits / 8> key);

  template<>
  inline void expand_key<128>(round_keys_t<128>& out, nonstd::span<const uint8_t, 128 / 8> key) {
    std::copy(key.begin(), key.end(), out.front().begin());

    table_t t;

    for (size_t round = 1; round < get_round_count<128>(); ++round) {
      for (uint8_t word = 0; word < 4; ++word) {
//        auto base = t.
        std::copy(,,t.begin())
      }
      if ()
    }
  }
}
